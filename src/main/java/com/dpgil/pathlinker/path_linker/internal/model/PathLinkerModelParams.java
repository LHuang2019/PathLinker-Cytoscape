package com.dpgil.pathlinker.path_linker.internal.model;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.cytoscape.model.CyColumn;
import org.cytoscape.model.CyEdge;
import org.cytoscape.model.CyNetwork;
import org.cytoscape.model.CyNode;

import com.dpgil.pathlinker.path_linker.internal.util.EdgeWeightType;
import com.dpgil.pathlinker.path_linker.internal.util.PathLinkerError;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
/**
 * The Class that holds and validates all the required parameters for PathLinkerModel
 *      in order to run ksp algorithm in CyRest
 */
@ApiModel(value="PathLinker Parameters", description="Parameters for PathLinkerModel")
public class PathLinkerModelParams {

    @ApiModelProperty(value = "Source node names separated by spaces. Must match the \"name\" column in the Node Table", example = "S1 S2 S3", required = true)
    public String sources; 

    @ApiModelProperty(value = "target node names separated by spaces. Must match the \"name\" column in the Node Table", example = "T1 T2 T3", required = true)
    public String targets;

    @ApiModelProperty(value = "Number of paths to compute. Default = 50", example = "50")
    public Integer k = 50;

    @ApiModelProperty(value = "The type of edge weights PathLinker will use to compute the cost/weight of a path. "
            + "Default set to UNWEIGHTED", 
            example = "UNWEIGHTED")
    public EdgeWeightType edgeWeightType = EdgeWeightType.UNWEIGHTED;

    @ApiModelProperty(value = "Cost of using additional edges in a path, essentially trading off longer, low-cost "
            + "paths with shorter, high-cost paths. Default = 0", example = "0")
    public Double edgePenalty = 0.0;

    @ApiModelProperty(value = "The name of the column in the Edge Table that contains the edge weight values. "
            + "Must be numerical type values", example = "weight")
    public String edgeWeightColumnName;

    @ApiModelProperty(value = "Allow source/target nodes to appear as intermediate nodes in computed paths",
            example = "false", dataType = "boolean")
    public boolean allowSourcesTargetsInPaths = false;

    @ApiModelProperty(value = "Include more than k paths if the path length/score is equal to the kth pathâ€™s length/score", 
            example = "false", dataType = "boolean")
    public boolean includeTiedPaths = false;

    @ApiModelProperty(value = "Skip the generation of the subnetwork/subnetwork view, the path rank column, "
            + "and the result panel in Cytoscape", 
            example = "false", dataType = "boolean")
    public Boolean skipSubnetworkGeneration = false;

    /** A mapping of the name of a node to the actual node object */
    private Map<String, CyNode> idToCyNode;
    /** A mapping of the node object to its name*/
    private Map<CyNode, String> cyNodeToId;

    /** list of source names */
    private Set<String> sourceNames;
    /** list of target names */
    private Set<String> targetNames;
    /** list of source names that is not in the network */
    private List<String> sourcesNotInNet; 
    /** list of target names that is not in the network */
    private List<String> targetsNotInNet;
    /** the sources to be used in the algorithm */
    private List<CyNode> sourcesList;
    /** the targets to be used in the algorithm */
    private List<CyNode> targetsList;

    /** list of PathLinkerError generated by validation */
    private List<PathLinkerError> errorList;
    /** resource path for creating the error */
    private String resourcePath;
    /** boolean indicating whether the validation allows user to continue */
    private boolean quit;

    /**
     * Getter method of cyNodeToId
     * @return cyNodeToId
     */
    @ApiModelProperty(hidden = true)
    public Map<CyNode, String> getCyNodeToId() {
        return this.cyNodeToId;
    }

    /**
     * Getter method of sourcesList
     * @return sourcesList
     */
    @ApiModelProperty(hidden = true)
    public List<CyNode> getSourcesList() {
        return this.sourcesList;
    }

    /**
     * Getter method of sourceNames
     * @return sourceNames
     */
    @ApiModelProperty(hidden = true)
    public Set<String> getSourceNames() {
        return this.sourceNames;
    }

    /**
     * Getter method of targetsList
     * @return targetsList
     */
    @ApiModelProperty(hidden = true)
    public List<CyNode> getTargetsList() {
        return this.targetsList;
    }

    /**
     * Getter method of targetNames
     * @return targetNames
     */
    @ApiModelProperty(hidden = true)
    public Set<String> getTargetNames() {
        return this.targetNames;
    }

    /**
     * Getter method of quit
     * @return true if quit is false
     *          otherwise false
     */
    @ApiModelProperty(hidden = true)
    public boolean continueStatus() {
        return !quit;
    }

    /**
     * Validation of the model parameter on the give network
     *      modify the model parameter object itself
     *      and initialize/sets varies other properties
     * @param network the given network for validation
     * @param resourcePath the resource path for error construction
     * @return list of PathLinkerError as result of the validation
     */
    @ApiModelProperty(hidden = true)
    public List<PathLinkerError> validate(CyNetwork network, String resourcePath) {
        // initialize errorList, resourcePath, and quit property
        errorList = new ArrayList<PathLinkerError>();
        this.resourcePath = resourcePath;
        quit = false;

        // check if network exists
        if (network == null) {
            String errorMsg = "Network does not exist";
            PathLinkerError error = new PathLinkerError(PathLinkerError.CY_NETWORK_NOT_FOUND_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.CY_NETWORK_NOT_FOUND_ERROR, 
                    errorMsg, null);

            errorList.add(error);
            return errorList;
        }

        // initialize source and target properties for validation
        prepareIdSourceTarget(network);

        // insert all missing sources/targets to the error message
        if (!sourcesNotInNet.isEmpty()) {
            int totalSources = sourcesList.size() + sourcesNotInNet.size();
            String errorMsg = sourcesList.size() + " out of " + totalSources + " sources are found in the network." +
                    "\n  - Sources not found: " + sourcesNotInNet.toString() +
                    "\n  - Please ensure the entered node names match the 'name' column of the Node Table.\n";

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg.replace("\n", ""), errorMsg);

            if (targetsList.isEmpty()) 
                quit = true;

            errorList.add(error);
        }

        // insert all missing targets/targets to the error message
        if (!targetsNotInNet.isEmpty()) {
            int totalTargets = targetsList.size() + targetsNotInNet.size();

            String errorMsg = targetsList.size() + " out of " + totalTargets + " targets are found in the network." +
                    "\n  - Targets not found: " + targetsNotInNet.toString() +
                    "\n  - Please ensure the entered node names match the 'name' column of the Node Table.\n";

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg.replace("\n", ""), errorMsg);

            if (targetsList.isEmpty()) 
                quit = true;

            errorList.add(error);
        }

        if (sourcesList.size() == 1 && sourcesList.equals(targetsList)) { 
            String errorMsg = "The only source node is the same as the only target node.\n"
                    + "PathLinker will not compute any paths. Please add more nodes to the sources or targets.\n\n";

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg.replace("\n", ""), errorMsg);

            errorList.add(error);
            quit = true;
        }

        // checks if all the edges in the graph have weights. Skip the check if edge weight type is unweighted
        // Error exists if a weighted option was selected, but not all edges have weights.
        PathLinkerError edgeWeightError = null;
        if (edgeWeightType != null && edgeWeightType != EdgeWeightType.UNWEIGHTED) {
            for (CyEdge edge : network.getEdgeList()) {
                try {
                    Double.parseDouble(network.getRow(edge).getRaw(edgeWeightColumnName).toString());
                } catch (NullPointerException  e) {
                    String errorMsg = "Weighted option is selected, but at least one edge does not have a weight in the selected edge weight column '" + 
                            edgeWeightColumnName + "'.\nPlease either select the Unweighted option, or ensure all edges have a weight to run PathLinker.\n";

                    edgeWeightError = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                            PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                            errorMsg.replace("\n", ""), errorMsg);

                    quit = true;
                    break;
                }
            }
        }

        // validate input k value
        if (k == null || k < 1) {
            String errorMsg = "Invalid k. K value cannot be less than 1";
            String uiErrorMsg = "Invalid value entered for k: " + k + ".\n  - Must be a positive integer.\n";

            if (!quit) {
                uiErrorMsg += "  - Setting to default: 50.\n";
                k = 50;
            }

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg, uiErrorMsg);

            errorList.add(error);
        }

        // check user input for edgeWeightType
        if (edgeWeightType == null) {
            String errorMsg = "Invalid edgeWeightType. edgeWeightType must be UNWEIGHTED, ADDITIVE, or PROBABILITIES" ;
            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg, null);

            errorList.add(error);

            return errorList;
        }

        // skip validation for other parameters if edge weight type is unweighted
        if (edgeWeightType == EdgeWeightType.UNWEIGHTED)
            return errorList;

        // validation for edge penalty
        if (edgePenalty == null || edgePenalty < 1 && edgeWeightType == EdgeWeightType.PROBABILITIES) {
            String errorMsg  = "Invalid edgePenalty. Edge penalty must be greater than or equal to 1 for edge weight type PROBABILITIES";
            String uiErrorMsg = "Invalid value entered for edge penalty: " + edgePenalty + 
                    ".\n  - Must be a number >= 1.0 for the probability/multiplicative type.\n";

            if (!quit) {
                uiErrorMsg += "  - Setting to default: 1.0.\n";
                edgePenalty = 1.0;
            }

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg, uiErrorMsg);

            errorList.add(error);
        }

        else if (edgePenalty == null || edgePenalty < 0) {
            String errorMsg  = "Invalid edgePenalty. Edge penalty must be greater than or equal to 0";
            String uiErrorMsg = "Invalid value entered for edge penalty: " + edgePenalty + 
                    ".\n  - Must be a number >= 0 for the additive setting.\n";

            if (!quit) {
                uiErrorMsg += "  - Setting to default: 0.0\n";
                edgePenalty = 1.0;
            }

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg, uiErrorMsg);

            errorList.add(error);
        }

        if (edgeWeightColumnName == null) {
            String errorMsg  = "edgeWeightColumnName is empty, " + edgeWeightType + " requires edgeWeightColumnName";

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg, null);

            errorList.add(error);
        }

        // validation for edge weight column name
        boolean columnNameError = true;
        Collection<CyColumn> columns = network.getDefaultEdgeTable().getColumns();  
        for (CyColumn column : columns) {
            if (column.getName().equals(edgeWeightColumnName) && (column.getType() == Double.class 
                    || column.getType() == Integer.class || column.getType() == Float.class 
                    || column.getType() == Long.class)) {
                columnNameError = false; // column name exists
                break;
            }
        }

        // column name does not exist
        if (columnNameError) {
            String errorMsg  = "Invalid edgeWeightColumnName. Column name must point to a valid edge column with numerical type";

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg, null);

            errorList.add(error);
        }

        // add edge weight column error in the end of the list for parsing purposes
        if (edgeWeightError != null)
            errorList.add(edgeWeightError);

        return errorList;
    }

    /**
     * set up the following variables:
     *      sourcesList, sourceNames, sourcesNotInNet
     *      targetsList, targetNames, targetsNoInNet
     *      idToCyNode
     */
    private void prepareIdSourceTarget(CyNetwork network) {
        // populates a mapping from the name of a node to the actual node object
        // used for converting user input to node objects. populates the map named _idToCyNode
        populateIdCyNodePair(network);

        // sets source and target
        setSources();
        setTargets();
    }

    /**
     * Populates idToCyNode, the map of node names to their objects
     * Populates cyNodeToId, the map of node objects to their names
     */
    private void populateIdCyNodePair(CyNetwork network) {
        idToCyNode = new HashMap<String, CyNode>();
        cyNodeToId = new HashMap<CyNode, String>();

        for (CyNode node : network.getNodeList()) {
            String nodeName = network.getRow(node).get(CyNetwork.NAME, String.class);
            idToCyNode.put(nodeName, node);
            cyNodeToId.put(node, nodeName);
        }
    }

    /**
     * Setter method for sourcesList, sourceNames, and sourcesNotInNet
     */
    private void setSources() {
        // stores the sources that were inputed but are not actually in the network, may have been mistyped
        sourcesNotInNet = new ArrayList<String>();
        // initialize the sourcesList here in case the text field is empty
        sourcesList = new ArrayList<CyNode>(); 

        // if nothing was entered, then return
        if (sources == null || sources.isEmpty()){
            String errorMsg = "Source field cannot be empty";

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg, null);

            errorList.add(error);
            return;
        }

        // splits the names by spaces
        String[] rawSourceNames = sources.split("\\s+");
        sourceNames = new HashSet<String>(Arrays.asList(rawSourceNames));

        // checks for mistyped source names
        for (String sourceName : sourceNames) {
            if (!idToCyNode.containsKey(sourceName))
                sourcesNotInNet.add(sourceName);
        }

        // generates a list of the valid source nodes to be used in the graph
        sourceNames.removeAll(sourcesNotInNet);
        sourcesList = stringsToNodes(sourceNames);
    }

    /**
     * Setter method for targetsList, targetNames, and targetsNotInNet
     */
    private void setTargets() {
        // stores the targets that were inputed but are not actually in the network, may have been mistyped
        targetsNotInNet = new ArrayList<String>();
        // initialize the targetsList here in case the text field is empty
        targetsList = new ArrayList<CyNode>(); 

        // if nothing was entered, then return
        if (targets == null || targets.length() == 0){
            String errorMsg = "Target field cannot be empty";

            PathLinkerError error = new PathLinkerError(PathLinkerError.INVALID_INPUT_CODE, 
                    PathLinkerError.RESOURCE_ERROR_ROOT + ":" + resourcePath + ":" + PathLinkerError.INVALID_INPUT_ERROR, 
                    errorMsg, null);

            errorList.add(error);
            return;
        }

        // splits the names by spaces
        String[] rawTargetNames = targets.split("\\s+");
        targetNames = new HashSet<String>(Arrays.asList(rawTargetNames));

        // checks for mistyped target  names
        for (String targetName : targetNames) {
            if (!idToCyNode.containsKey(targetName))
                targetsNotInNet.add(targetName);
        }

        // generates a list of the valid target nodes to be used in the graph
        targetNames.removeAll(targetsNotInNet);
        targetsList = stringsToNodes(targetNames);
    }

    /**
     * Converts an array of node names to a list of the actual corresponding nodes
     * @param names the names of the nodes that we want
     * @return a list of the actual node objects with the given names
     */
    private List<CyNode> stringsToNodes(Set<String> names) {
        List<CyNode> nodes = new ArrayList<CyNode>();

        for (String name : names) {
            if (idToCyNode.containsKey(name)) {
                nodes.add(idToCyNode.get(name));
            }
        }

        return nodes;
    }
}